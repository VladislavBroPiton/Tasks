Рассмотрим одну задачу, которая на leetcode маркирована как "medium", хотя на самом деле это крайне сложная задача. Примечательна она тем, что допускает в разной степени оптимальные решения, самые упрощённые из которых действительно весьма просты, а самые оптимальные ещё не найдены современной наукой. В этой задаче ценно то, что на её примере можно изучать целый ряд техник программирования.  

Примеры кода даются на языке Scheme, который я использую для объяснения студентам теоретических основ конструирования программ. Некоторые из примеров можно легко перевести на другие языки программирования. Но мы же не будем публиковать решения задач leetcode на языке, принимаемом leetcode, правильно?  

### Постановка задачи

У нас имеется банкомат с кассетой, отделения которой заряжены купюрами разных номиналов. Клиент просит банкомат выдать ему определённую сумму. Необходимо найти все варианты выдачи этой суммы минимальным количеством купюр.  
Для простоты картины будем считать, что если в каком-то отделении кассеты вообще есть купюры, то их там неограниченно много. Такое допущение принципиально ничего не меняет в решении задачи, но несколько упрощает код.  
В отличие от нашей задачи, где требуется найти все варианты выдачи, на leetcode ищут какое-нибудь минимальное решение, или, точнее, его длину. Такая задача требует гораздо меньше вычислений.  

### Простейший пример
В кассете имеются купюры номиналом 5000, 2000, 1000, 500, 200 и 100 рублей. Просим выдать 6400 рублей, получаем 5000+1000+200+200, решение единственно.  
Первый подход к снаряду – жадный алгоритм  
**Простейшим решением**, которое сразу приходит в голову, является жадный алгоритм: выдаём самые крупные купюры, пока это возможно, потом переходим к более мелким и т.д.  
В нашем примере:  
6400 >= 5000? Да, выдаём 5000. Остаётся 1400.  

1400 >= 5000? Нет.  

1400 >= 2000? Нет.  

1400 >= 1000? Да, выдаём 1000. Остаётся 400.  

400 >= 1000? Нет.  

400 >= 500? Нет.  

400 >= 200? Да, выдаём 200. Остаётся 200.  

200 >= 200? Да, выдаём 200. Остаётся 0. Задача решена.  

Это решение можно представить следующим кодом на языке Scheme:  

```
(define *купюры* '(5000 2000 1000 500 200 100))  

(define	(оптимальный-размен сумма)  
  (жадный-размен сумма *купюры*))  

(define (жадный-размен сумма купюры)  
  (cond  
   ((zero? сумма) '())  
   ((null? купюры) '())  
   ((<= (car купюры) сумма)   
    (cons (car купюры)   
          (жадный-размен (- сумма (car купюры))   
                          купюры)))  
   (else (жадный-размен сумма (cdr купюры)))))  
```

> (оптимальный-размен 6400)  

(5000 1000 200 200)  

Тут у нас, однако, возникают серьёзные проблемы.  

Во-первых, жадный алгоритм по своей природе выдаёт только одно решение, а мы хотим получить все.  

Во-вторых, это решение может быть неоптимально:  

> (define *купюры* '(5000 2000 100))  

> (оптимальный-размен 6000)  

(5000 100 100 100 100 100 100 100 100 100 100)  

Пятёрка сразу захватила слишком много денег, и остаток нам пришлось добирать сотнями, хотя оптимальным решением в данном случае было бы (2000 2000 2000).  

В-третьих, при определённых значениях купюр и размениваемой суммы алгоритм может зайти в тупик и не найти верного решения:  

> (define *купюры* '(2000 1500))       

> (оптимальный-размен 4500)       

(2000 2000)  

Возможно, полный рекурсивный перебор?  

Следующая мысль, приходящая в голову – реализовать полный перебор методом рекурсивного спуска. Сразу ясно, что это наихудшее по времени и памяти решение, перебирающее и хранящее в качестве промежуточных результатов все возможные комбинации купюр, дающие сумму не выше заданной. Кроме того, обход тупиков в таком случае будет довольно запутанным делом, поэтому не станем тратить силы на программирование этого решения, трудоёмкого в написании и убогого по ожидаемому результату.  

Недетерминированное программирование  

Подумаем, как нам ограничить ненужные переборы в рекурсии, а заодно справиться с проблемой тупиков. Для этого нужен какой-то механизм отсечки логических ветвей алгоритма, зашедших не туда. Если смотреть в общем, язык Scheme предлагает для решения неудобств с выходом из функции в неактуальное уже место механизм продолжений (continuations). Однако, пользоваться механизмом продолжений в исходном виде по существу не сильно привлекательнее, чем строить программу на голых go to. Поэтому на базе продолжений обычно строятся более приближённые к практическим задачам механизмы, одним из которых является недетерминированная специальная форма amb. Воспользуемся, например, реализацией Такафуми Шидо.  

Специальная форма amb принимает произвольное число параметров и имеет следующую денотационную семантику:  

(amb)означает выбор из нуля альтернатив, то есть то, что алгоритм зашёл не туда.  

(amb x)означает выбор из одной альтернативы, то есть то же самое, что просто x.  

(amb x1 x2 ... xN), где N ⩾ 2, означает выбор из N альтернатив. При этом наша программа как бы распадается в мультивселенной на N разных программ, в каждой из которых реализовался свой вариант значения функции amb. Буквально как если бы мы кинули игральный кубик с N значениями, и рассматривали бы разные миры, в каждом из которых на кубике выпало бы своё значение. В дальнейшем (в отличие от квантовых мультивселенных) эти программы можно вновь собрать из разных миров в множество их результатов в одном мире формой set-of.  

Заметим, что amb не следует понимать как функцию порождения параллельных потоков выполнения вроде fork() (хотя такие интерпретации операционной семантики amb в истории встречались). Скорее, по обычному механизму реализации это более похоже на сопрограммы (coroutines) – поток выполнения один, но связан с текстом программы нелинейно.  

(assert condition) – форма, означающая, что в этом месте программы должно выполняться условие condition (и сама имеющая значение этого условия). Если условие ложно, то мы оказались в неправильном мире, то есть наш алгоритм зашёл в тупик. Ввиду своей семантики, обычно форма assert используется императивно.  

(set-of expr) – форма, возвращающая список всех допустимых значений выражения expr в разных мирах.  

Реализация amb от Шидо (amb.scm):  
```
